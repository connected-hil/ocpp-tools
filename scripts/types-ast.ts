import {
  factory,
  SyntaxKind,
  type Node,
  createPrinter,
  NewLineKind,
  ScriptTarget,
  ScriptKind,
  createSourceFile,
  EmitHint,
  ListFormat,
} from "typescript";
import fs from "fs";
import { type GeneratorDefinition, capitalize } from "./common";
import { messageDirections } from "./message-direction";

const errorCodes = {
  v16: [
    "NotImplemented",
    "NotSupported",
    "InternalError",
    "ProtocolError",
    "SecurityError",
    "FormationViolation",
    "PropertyConstraintViolation",
    "OccurenceConstraintViolation",
    "TypeConstraintViolation",
    "GenericError",
  ],
};

const unionTypeAST = (name: string, types: string[]): Node =>
  factory.createTypeAliasDeclaration(
    [factory.createToken(SyntaxKind.ExportKeyword)],
    factory.createIdentifier(name),
    undefined,
    factory.createUnionTypeNode(
      types.map((t) =>
        factory.createTypeReferenceNode(factory.createIdentifier(t), undefined)
      )
    )
  );

const enumAST = (name: string, enums: string[]): Node =>
  factory.createEnumDeclaration(
    [factory.createToken(SyntaxKind.ExportKeyword)],
    factory.createIdentifier(name),
    enums.map((n) =>
      factory.createEnumMember(
        factory.createIdentifier(n),
        factory.createStringLiteral(n)
      )
    )
  );

const importAST = (name: string, path: string): Node =>
  factory.createImportDeclaration(
    undefined,
    factory.createImportClause(
      false,
      undefined,
      factory.createNamedImports([
        factory.createImportSpecifier(
          true,
          undefined,
          factory.createIdentifier(name)
        ),
      ])
    ),
    factory.createStringLiteral(path),
    undefined
  );

const exportTypeAST = (name: string): Node =>
  factory.createExportDeclaration(
    undefined,
    true,
    factory.createNamedExports([
      factory.createExportSpecifier(
        false,
        undefined,
        factory.createIdentifier(name)
      ),
    ]),
    undefined,
    undefined
  );

const importsAST = (definitions: GeneratorDefinition[]): Node[] =>
  definitions.map(({ version, title, typeFile }) =>
    importAST(
      title,
      [
        ".",
        version,
        typeFile.split("/").reverse()[0].replace(/\.ts$/, ""),
      ].join("/")
    )
  );

export const generateTypesIndex = (
  version: string,
  definitions: GeneratorDefinition[]
): void => {
  fs.mkdirSync(["src", "types", version].join("/"), { recursive: true });
  const filename = ["src", "types", "index.ts"].join("/");
  const printer = createPrinter({ newLine: NewLineKind.LineFeed });
  const titles = definitions.map((s) => s.title);
  const sourceFile = createSourceFile(
    filename,
    "",
    ScriptTarget.Latest,
    false,
    ScriptKind.TS
  );
  const upperCaseVersion = capitalize(version);

  // Get message direction configuration
  const directionConfig = messageDirections[version];
  
  // Extract action names (without version suffix and Request/Response)
  const getActionName = (title: string): string => 
    title.replace(capitalize(version), "").replace(/Request|Response/, "");
  
  // Filter by direction
  const cpActions = directionConfig.cpToCSMS;
  const csmsActions = directionConfig.csmsToCp;
  
  // Get request and response types by direction
  const cpRequestTypes = titles.filter(
    (t) => /Request/.exec(t) && cpActions.includes(getActionName(t))
  );
  const csmsRequestTypes = titles.filter(
    (t) => /Request/.exec(t) && csmsActions.includes(getActionName(t))
  );
  const cpResponseTypes = titles.filter(
    (t) => /Response/.exec(t) && cpActions.includes(getActionName(t))
  );
  const csmsResponseTypes = titles.filter(
    (t) => /Response/.exec(t) && csmsActions.includes(getActionName(t))
  );

  const types: string[] = [
    `// **** Generated by scripts/types-ast.ts for version ${version} ****`,
    "",
    printer.printList(
      ListFormat.MultiLine,
      factory.createNodeArray(importsAST(definitions)),
      sourceFile
    ),
    "",
    "// Export all imported types",
    printer.printList(
      ListFormat.MultiLine,
      factory.createNodeArray(
        titles.map((title) => exportTypeAST(title))
      ),
      sourceFile
    ),
    "",
    "// ==================== Action Types ====================",
    "",
    "/** Actions initiated by Charge Point */",
    printer.printNode(
      EmitHint.Unspecified,
      unionTypeAST(
        ["CPAction", upperCaseVersion].join(""),
        cpActions.map((a) => `"${a}"`)
      ),
      sourceFile
    ),
    "",
    "/** Actions initiated by CSMS (Central System) */",
    printer.printNode(
      EmitHint.Unspecified,
      unionTypeAST(
        ["CSMSAction", upperCaseVersion].join(""),
        csmsActions.map((a) => `"${a}"`)
      ),
      sourceFile
    ),
    "",
    "/** All OCPP actions */",
    printer.printNode(
      EmitHint.Unspecified,
      unionTypeAST(
        ["Action", upperCaseVersion].join(""),
        titles
          .filter((t) => /Request/.exec(t))
          .map((t) => t.replace(capitalize(version), ""))
          .map((a) => `"${a.replace(/Request/, "")}"`)
      ),
      sourceFile
    ),
    printer.printNode(
      EmitHint.Unspecified,
      enumAST(
        ["ActionName", upperCaseVersion].join(""),
        titles
          .filter((t) => /Request/.exec(t))
          .map((t) => t.replace(capitalize(version), ""))
          .map((a) => `${a.replace(/Request/, "")}`)
      ),
      sourceFile
    ),
    "",
    "// ==================== Request Types ====================",
    "",
    "/** Request messages sent from Charge Point to CSMS */",
    printer.printNode(
      EmitHint.Unspecified,
      unionTypeAST(
        ["CPRequestType", upperCaseVersion].join(""),
        cpRequestTypes
      ),
      sourceFile
    ),
    "",
    "/** Request messages sent from CSMS to Charge Point */",
    printer.printNode(
      EmitHint.Unspecified,
      unionTypeAST(
        ["CSMSRequestType", upperCaseVersion].join(""),
        csmsRequestTypes
      ),
      sourceFile
    ),
    "",
    "/** All OCPP request types */",
    printer.printNode(
      EmitHint.Unspecified,
      unionTypeAST(
        ["OCPPRequestType", upperCaseVersion].join(""),
        titles.filter((t) => /Request/.exec(t))
      ),
      sourceFile
    ),
    "",
    "// ==================== Response Types ====================",
    "",
    "/** Response messages sent from CSMS to Charge Point (in response to CP requests) */",
    printer.printNode(
      EmitHint.Unspecified,
      unionTypeAST(
        ["CPResponseType", upperCaseVersion].join(""),
        cpResponseTypes
      ),
      sourceFile
    ),
    "",
    "/** Response messages sent from Charge Point to CSMS (in response to CSMS requests) */",
    printer.printNode(
      EmitHint.Unspecified,
      unionTypeAST(
        ["CSMSResponseType", upperCaseVersion].join(""),
        csmsResponseTypes
      ),
      sourceFile
    ),
    "",
    "/** All OCPP response types */",
    printer.printNode(
      EmitHint.Unspecified,
      unionTypeAST(
        ["OCPPResponseType", upperCaseVersion].join(""),
        titles.filter((t) => /Response/.exec(t))
      ),
      sourceFile
    ),
    "",
    "// ==================== Error Codes ====================",
    "",
    printer.printNode(
      EmitHint.Unspecified,
      enumAST(
        ["OCPPErrorCode", version.toLocaleUpperCase()].join(""),
        errorCodes.v16
      ),
      sourceFile
    ),
    "",
    "// ==================== RPC Message Types ====================",
    "",
    printer.printNode(
      EmitHint.Unspecified,
      unionTypeAST(["OCPPRpcMessage", upperCaseVersion].join(""), [
        ["RpcCall", upperCaseVersion].join(""),
        ["RpcCallResult", upperCaseVersion].join(""),
        ["RpcCallError", upperCaseVersion].join(""),
      ]),
      sourceFile
    ),
    "",
    "",
  ];

  fs.appendFileSync(filename, types.join("\n"), { encoding: "utf-8" });
};
