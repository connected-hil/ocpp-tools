import {
  factory,
  SyntaxKind,
  type Node,
  createPrinter,
  NewLineKind,
  ScriptTarget,
  ScriptKind,
  createSourceFile,
  EmitHint,
  ListFormat,
} from "typescript";
import fs from "fs";
import { type GeneratorDefinition, capitalize } from "./common";

const unionTypeAST = (name: string, types: string[]): Node =>
  factory.createTypeAliasDeclaration(
    [factory.createToken(SyntaxKind.ExportKeyword)],
    factory.createIdentifier(name),
    undefined,
    factory.createUnionTypeNode(
      types.map((t) =>
        factory.createTypeReferenceNode(factory.createIdentifier(t), undefined)
      )
    )
  );

const importAST = (name: string, path: string): Node =>
  factory.createImportDeclaration(
    undefined,
    factory.createImportClause(
      false,
      undefined,
      factory.createNamedImports([
        factory.createImportSpecifier(
          true,
          undefined,
          factory.createIdentifier(name)
        ),
      ])
    ),
    factory.createStringLiteral(path),
    undefined
  );

const importsAST = (definitions: GeneratorDefinition[]): Node[] =>
  definitions.map(({ version, title, typeFile }) =>
    importAST(
      title,
      [
        ".",
        version,
        typeFile.split("/").reverse()[0].replace(/\.ts$/, ""),
      ].join("/")
    )
  );

export const generateTypesIndex = (
  version: string,
  definitions: GeneratorDefinition[]
): void => {
  fs.mkdirSync(["src", "types", version].join("/"), { recursive: true });
  const filename = ["src", "types", "index.ts"].join("/");
  const printer = createPrinter({ newLine: NewLineKind.LineFeed });
  const titles = definitions.map((s) => s.title);
  const sourceFile = createSourceFile(
    filename,
    "",
    ScriptTarget.Latest,
    false,
    ScriptKind.TS
  );
  const upperCaseVersion = capitalize(version);

  const types: string[] = [
    `// **** Generated by scripts/types-ast.ts for version ${version} ****`,
    printer.printList(
      ListFormat.MultiLine,
      factory.createNodeArray(importsAST(definitions)),
      sourceFile
    ),
    printer.printNode(
      EmitHint.Unspecified,
      factory.createExportDeclaration(
        undefined,
        false,
        factory.createNamedExports([
          factory.createExportSpecifier(
            false,
            "Action",
            [`Action`, upperCaseVersion].join("")
          ),
        ]),
        factory.createStringLiteral([".", version].join("/")),
        undefined
      ),
      sourceFile
    ),
    printer.printNode(
      EmitHint.Unspecified,
      factory.createExportDeclaration(
        undefined,
        false,
        factory.createNamedExports([
          factory.createExportSpecifier(
            false,
            "ErrorCode",
            [`ErrorCode`, upperCaseVersion].join("")
          ),
        ]),
        factory.createStringLiteral([".", version].join("/")),
        undefined
      ),
      sourceFile
    ),
    printer.printNode(
      EmitHint.Unspecified,
      unionTypeAST(
        ["OCPPRequestType", upperCaseVersion].join(""),
        titles.filter((t) => /Request/.exec(t) || /Notification/.exec(t))
      ),
      sourceFile
    ),
    printer.printNode(
      EmitHint.Unspecified,
      unionTypeAST(
        ["OCPPResponseType", upperCaseVersion].join(""),
        titles.filter((t) => /Response/.exec(t))
      ),
      sourceFile
    ),
    printer.printNode(
      EmitHint.Unspecified,
      unionTypeAST(["OCPPRpcMessage", upperCaseVersion].join(""), [
        ["RpcCall", upperCaseVersion].join(""),
        ["RpcCallResult", upperCaseVersion].join(""),
        ["RpcCallError", upperCaseVersion].join(""),
      ]),
      sourceFile
    ),
    "",
    "",
    "",
  ];

  fs.appendFileSync(filename, types.join("\n"), { encoding: "utf-8" });
};
